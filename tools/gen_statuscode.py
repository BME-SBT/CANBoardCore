#!/usr/bin/env python3
import copy
import os.path
import yaml

try:
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper


def get_app_status():
    data = {}

    if os.path.exists('status.yaml'):
        with open('status.yaml', 'r') as file:
            contents = '\n'.join(file.readlines())
            data = yaml.load(contents, Loader=Loader)

    return data


def get_core_status():
    data = {}
    with open('lib/core/status.yaml', 'r') as file:
        contents = '\n'.join(file.readlines())
        data = yaml.load(contents, Loader=Loader)

    return data


def extract_names(data, prefix):
    names = []
    if isinstance(data, list):
        for item in data:
            if isinstance(item, dict):
                if len(item.keys()) != 1:
                    raise Exception("invalid status item: must be single key-value mappings")
                names.append((f"{prefix}_{list(item.keys())[0].upper()}", item[list(item.keys())[0]]))
            else:
                names.append((f"{prefix}_{item.upper()}", '<n/a>'))

    else:
        for key in data.keys():
            key_part = key.upper()
            new_prefix = prefix + "_" + key_part
            names.extend(extract_names(data[key], new_prefix))
    return names


def gen_statuses(data: dict):
    statuses = {}

    core_status: dict = data['core_status']
    core_levels = []
    for key in core_status.keys():
        key_part = 'STATUS_' + key.upper()
        names = extract_names(core_status[key], key_part)
        core_levels.append(names)

    app_status: dict = data['app_status']
    app_levels = []
    if app_status is not None:
        for key in app_status.keys():
            key_part = 'STATUS_APP_' + key.upper()
            names = extract_names(app_status[key], key_part)
            app_levels.append(names)

    counter = 1
    for core_level in core_levels:
        level_start = counter
        for level in core_level:
            statuses[counter] = level
            counter += 1
        if counter <= level_start + 0xf:
            counter = level_start + 0xf

    def get_level_status(lvl: int):
        min_level = lvl * 0x10
        max_level = min_level + 0xf

        stts = []
        for k in statuses.keys():
            if min_level <= k <= max_level:
                stts.append((k, statuses[k]))
        return stts

    # collapse small blocks
    if len(statuses.keys()) > 0x80:
        raise Exception("too many platform statuses")
    while counter > 0x80:
        # collapse top 2 blocks
        current_lvl = counter % 0x10
        for i in range(current_lvl, 0):
            current_len = len(get_level_status(i))
            last_len = len(get_level_status(i - 1))
            if current_len + last_len <= 0xf:
                last = get_level_status(i - 1)
                last_max = max(map(lambda x: x[0], last)) + 1
                # collapse the two levels
                for current in get_level_status(i):
                    del statuses[current[0]]
                    statuses[last_max] = current[1]
                    last_max += 1

            # shift all upper levels
            upper_levels = [i for i in range(current_lvl, i, 0x10)]
            upper_levels.reverse()

            counter = 0

            for upper_level in upper_levels:
                upper_statuses = get_level_status(upper_level)

                for sts in upper_statuses:
                    del statuses[sts[0]]
                    statuses[sts[0] - 0x10] = sts[1]
                    counter = max(counter, sts[0] - 0x10)
            break

    counter = 0x80
    for app_level in app_levels:
        level_start = counter
        for level in app_level:
            statuses[counter] = level
            counter += 1
        if counter <= level_start + 0xf:
            counter = level_start + 0xf

    return statuses


def gen_header(statuses):
    header_path = "lib/core/include/gen_status.h"
    print(f"generating status header: {header_path}")

    header_template = """// THIS FILE IS GENERATED BY gen_statuscode.py
// DO NOT EDIT
#ifndef GEN_STATUS_H
#define GEN_STATUS_H

#include "lib/inttypes.h"
    
enum class PlatformStatus {{
    STATUS_OK = 0x0,
{0}
}};
    
#ifdef STATUS_DEBUG
static const struct
{{
    u8 statuscode;
    const char name[32];
}} status_name_map[] = {{
{1}   
}};
inline const char* status_lookup_code(u8 code) {{ 
    for(unsigned int i = 0; i < sizeof(status_name_map); i++) {{
        auto& item = status_name_map[i];
        if(item.statuscode == code) {{
            return item.name;
        }}
    }}
    return "<invalid>";
}}
#else
inline const char* status_lookup_code(u8 code) {{ return "<not supported>"; }}
#endif
    
#endif
"""

    enum_items = []
    status_name_map_items = []
    for statuscode, item in statuses.items():
        enum_items.append(f"    {item[0]} = {hex(statuscode)}")
        name = item[0] if len(item[0]) < 32 else item[0][:32]
        status_name_map_items.append(f"    {{ {hex(statuscode)}, \"{name}\" }}")

    enum_text = ',\n'.join(enum_items)
    map_text = ',\n'.join(status_name_map_items)

    header_text = header_template.format(enum_text, map_text)
    with open(header_path, 'w') as header_file:
        header_file.write(header_text)

if __name__ == "__main__":
    app_status = get_app_status()
    core_status = get_core_status()
    statuses = gen_statuses(app_status | core_status)

    gen_header(statuses)
